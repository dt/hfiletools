#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class HFileServiceAction:
  fetchValuesSingle = 0
  fetchValuesMulti = 1
  getIterator = 2
  fetchValuesForPrefixes = 3
  fetchValuesForSplitKeys = 4

  _VALUES_TO_NAMES = {
    0: "fetchValuesSingle",
    1: "fetchValuesMulti",
    2: "getIterator",
    3: "fetchValuesForPrefixes",
    4: "fetchValuesForSplitKeys",
  }

  _NAMES_TO_VALUES = {
    "fetchValuesSingle": 0,
    "fetchValuesMulti": 1,
    "getIterator": 2,
    "fetchValuesForPrefixes": 3,
    "fetchValuesForSplitKeys": 4,
  }


class HFileServiceException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HFileServiceException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SingleHFileKeyRequest:
  """
  Attributes:
   - hfileName
   - sortedKeys
   - perKeyValueLimit
   - countOnly
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hfileName', None, None, ), # 1
    (2, TType.LIST, 'sortedKeys', (TType.STRING,None), None, ), # 2
    (3, TType.I32, 'perKeyValueLimit', None, None, ), # 3
    (4, TType.BOOL, 'countOnly', None, None, ), # 4
  )

  def __init__(self, hfileName=None, sortedKeys=None, perKeyValueLimit=None, countOnly=None,):
    self.hfileName = hfileName
    self.sortedKeys = sortedKeys
    self.perKeyValueLimit = perKeyValueLimit
    self.countOnly = countOnly

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hfileName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sortedKeys = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.sortedKeys.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.perKeyValueLimit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.countOnly = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SingleHFileKeyRequest')
    if self.hfileName is not None:
      oprot.writeFieldBegin('hfileName', TType.STRING, 1)
      oprot.writeString(self.hfileName)
      oprot.writeFieldEnd()
    if self.sortedKeys is not None:
      oprot.writeFieldBegin('sortedKeys', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.sortedKeys))
      for iter6 in self.sortedKeys:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.perKeyValueLimit is not None:
      oprot.writeFieldBegin('perKeyValueLimit', TType.I32, 3)
      oprot.writeI32(self.perKeyValueLimit)
      oprot.writeFieldEnd()
    if self.countOnly is not None:
      oprot.writeFieldBegin('countOnly', TType.BOOL, 4)
      oprot.writeBool(self.countOnly)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hfileName)
    value = (value * 31) ^ hash(self.sortedKeys)
    value = (value * 31) ^ hash(self.perKeyValueLimit)
    value = (value * 31) ^ hash(self.countOnly)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SingleHFileKeyResponse:
  """
  Attributes:
   - values
   - keyCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'values', (TType.I32,None,TType.STRING,None), None, ), # 1
    (2, TType.I32, 'keyCount', None, None, ), # 2
  )

  def __init__(self, values=None, keyCount=None,):
    self.values = values
    self.keyCount = keyCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.values = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin()
          for _i11 in xrange(_size7):
            _key12 = iprot.readI32();
            _val13 = iprot.readString();
            self.values[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.keyCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SingleHFileKeyResponse')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.STRING, len(self.values))
      for kiter14,viter15 in self.values.items():
        oprot.writeI32(kiter14)
        oprot.writeString(viter15)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.keyCount is not None:
      oprot.writeFieldBegin('keyCount', TType.I32, 2)
      oprot.writeI32(self.keyCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.keyCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MultiHFileKeyResponse:
  """
  Attributes:
   - values
   - keyCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'values', (TType.I32,None,TType.LIST,(TType.STRING,None)), None, ), # 1
    (2, TType.I32, 'keyCount', None, None, ), # 2
  )

  def __init__(self, values=None, keyCount=None,):
    self.values = values
    self.keyCount = keyCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.values = {}
          (_ktype17, _vtype18, _size16 ) = iprot.readMapBegin()
          for _i20 in xrange(_size16):
            _key21 = iprot.readI32();
            _val22 = []
            (_etype26, _size23) = iprot.readListBegin()
            for _i27 in xrange(_size23):
              _elem28 = iprot.readString();
              _val22.append(_elem28)
            iprot.readListEnd()
            self.values[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.keyCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MultiHFileKeyResponse')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.values))
      for kiter29,viter30 in self.values.items():
        oprot.writeI32(kiter29)
        oprot.writeListBegin(TType.STRING, len(viter30))
        for iter31 in viter30:
          oprot.writeString(iter31)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.keyCount is not None:
      oprot.writeFieldBegin('keyCount', TType.I32, 2)
      oprot.writeI32(self.keyCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.keyCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrefixRequest:
  """
  Attributes:
   - hfileName
   - sortedKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hfileName', None, None, ), # 1
    (2, TType.LIST, 'sortedKeys', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, hfileName=None, sortedKeys=None,):
    self.hfileName = hfileName
    self.sortedKeys = sortedKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hfileName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sortedKeys = []
          (_etype35, _size32) = iprot.readListBegin()
          for _i36 in xrange(_size32):
            _elem37 = iprot.readString();
            self.sortedKeys.append(_elem37)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrefixRequest')
    if self.hfileName is not None:
      oprot.writeFieldBegin('hfileName', TType.STRING, 1)
      oprot.writeString(self.hfileName)
      oprot.writeFieldEnd()
    if self.sortedKeys is not None:
      oprot.writeFieldBegin('sortedKeys', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.sortedKeys))
      for iter38 in self.sortedKeys:
        oprot.writeString(iter38)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hfileName)
    value = (value * 31) ^ hash(self.sortedKeys)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrefixResponse:
  """
  Attributes:
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'values', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 1
  )

  def __init__(self, values=None,):
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.values = {}
          (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin()
          for _i43 in xrange(_size39):
            _key44 = iprot.readString();
            _val45 = []
            (_etype49, _size46) = iprot.readListBegin()
            for _i50 in xrange(_size46):
              _elem51 = iprot.readString();
              _val45.append(_elem51)
            iprot.readListEnd()
            self.values[_key44] = _val45
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrefixResponse')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.values))
      for kiter52,viter53 in self.values.items():
        oprot.writeString(kiter52)
        oprot.writeListBegin(TType.STRING, len(viter53))
        for iter54 in viter53:
          oprot.writeString(iter54)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MultiHFileSplitKeyRequest:
  """
  Attributes:
   - hfileName
   - retired_sortedPrefixes
   - retired_sortedSuffixes
   - splitKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hfileName', None, None, ), # 1
    (2, TType.LIST, 'retired_sortedPrefixes', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'retired_sortedSuffixes', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'splitKey', (TType.LIST,(TType.STRING,None)), None, ), # 4
  )

  def __init__(self, hfileName=None, retired_sortedPrefixes=None, retired_sortedSuffixes=None, splitKey=None,):
    self.hfileName = hfileName
    self.retired_sortedPrefixes = retired_sortedPrefixes
    self.retired_sortedSuffixes = retired_sortedSuffixes
    self.splitKey = splitKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hfileName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.retired_sortedPrefixes = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = iprot.readString();
            self.retired_sortedPrefixes.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.retired_sortedSuffixes = []
          (_etype64, _size61) = iprot.readListBegin()
          for _i65 in xrange(_size61):
            _elem66 = iprot.readString();
            self.retired_sortedSuffixes.append(_elem66)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.splitKey = []
          (_etype70, _size67) = iprot.readListBegin()
          for _i71 in xrange(_size67):
            _elem72 = []
            (_etype76, _size73) = iprot.readListBegin()
            for _i77 in xrange(_size73):
              _elem78 = iprot.readString();
              _elem72.append(_elem78)
            iprot.readListEnd()
            self.splitKey.append(_elem72)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MultiHFileSplitKeyRequest')
    if self.hfileName is not None:
      oprot.writeFieldBegin('hfileName', TType.STRING, 1)
      oprot.writeString(self.hfileName)
      oprot.writeFieldEnd()
    if self.retired_sortedPrefixes is not None:
      oprot.writeFieldBegin('retired_sortedPrefixes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.retired_sortedPrefixes))
      for iter79 in self.retired_sortedPrefixes:
        oprot.writeString(iter79)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.retired_sortedSuffixes is not None:
      oprot.writeFieldBegin('retired_sortedSuffixes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.retired_sortedSuffixes))
      for iter80 in self.retired_sortedSuffixes:
        oprot.writeString(iter80)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.splitKey is not None:
      oprot.writeFieldBegin('splitKey', TType.LIST, 4)
      oprot.writeListBegin(TType.LIST, len(self.splitKey))
      for iter81 in self.splitKey:
        oprot.writeListBegin(TType.STRING, len(iter81))
        for iter82 in iter81:
          oprot.writeString(iter82)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hfileName)
    value = (value * 31) ^ hash(self.retired_sortedPrefixes)
    value = (value * 31) ^ hash(self.retired_sortedSuffixes)
    value = (value * 31) ^ hash(self.splitKey)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class KeyToValuesResponse:
  """
  Attributes:
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'values', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 1
  )

  def __init__(self, values=None,):
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.values = {}
          (_ktype84, _vtype85, _size83 ) = iprot.readMapBegin()
          for _i87 in xrange(_size83):
            _key88 = iprot.readString();
            _val89 = []
            (_etype93, _size90) = iprot.readListBegin()
            for _i94 in xrange(_size90):
              _elem95 = iprot.readString();
              _val89.append(_elem95)
            iprot.readListEnd()
            self.values[_key88] = _val89
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('KeyToValuesResponse')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.values))
      for kiter96,viter97 in self.values.items():
        oprot.writeString(kiter96)
        oprot.writeListBegin(TType.STRING, len(viter97))
        for iter98 in viter97:
          oprot.writeString(iter98)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class KeyValueItem:
  """
  Attributes:
   - key
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, key=None, value=None,):
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('KeyValueItem')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IteratorRequest:
  """
  Attributes:
   - hfileName
   - includeValues
   - lastKey
   - skipKeys
   - responseLimit
   - endKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hfileName', None, None, ), # 1
    (2, TType.BOOL, 'includeValues', None, None, ), # 2
    (3, TType.STRING, 'lastKey', None, None, ), # 3
    (4, TType.I32, 'skipKeys', None, None, ), # 4
    (5, TType.I32, 'responseLimit', None, None, ), # 5
    (6, TType.STRING, 'endKey', None, None, ), # 6
  )

  def __init__(self, hfileName=None, includeValues=None, lastKey=None, skipKeys=None, responseLimit=None, endKey=None,):
    self.hfileName = hfileName
    self.includeValues = includeValues
    self.lastKey = lastKey
    self.skipKeys = skipKeys
    self.responseLimit = responseLimit
    self.endKey = endKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hfileName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.includeValues = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.lastKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.skipKeys = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.responseLimit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.endKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IteratorRequest')
    if self.hfileName is not None:
      oprot.writeFieldBegin('hfileName', TType.STRING, 1)
      oprot.writeString(self.hfileName)
      oprot.writeFieldEnd()
    if self.includeValues is not None:
      oprot.writeFieldBegin('includeValues', TType.BOOL, 2)
      oprot.writeBool(self.includeValues)
      oprot.writeFieldEnd()
    if self.lastKey is not None:
      oprot.writeFieldBegin('lastKey', TType.STRING, 3)
      oprot.writeString(self.lastKey)
      oprot.writeFieldEnd()
    if self.skipKeys is not None:
      oprot.writeFieldBegin('skipKeys', TType.I32, 4)
      oprot.writeI32(self.skipKeys)
      oprot.writeFieldEnd()
    if self.responseLimit is not None:
      oprot.writeFieldBegin('responseLimit', TType.I32, 5)
      oprot.writeI32(self.responseLimit)
      oprot.writeFieldEnd()
    if self.endKey is not None:
      oprot.writeFieldBegin('endKey', TType.STRING, 6)
      oprot.writeString(self.endKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hfileName)
    value = (value * 31) ^ hash(self.includeValues)
    value = (value * 31) ^ hash(self.lastKey)
    value = (value * 31) ^ hash(self.skipKeys)
    value = (value * 31) ^ hash(self.responseLimit)
    value = (value * 31) ^ hash(self.endKey)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IteratorResponse:
  """
  Attributes:
   - values
   - lastKey
   - skipKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.STRUCT,(KeyValueItem, KeyValueItem.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'lastKey', None, None, ), # 2
    (3, TType.I32, 'skipKeys', None, None, ), # 3
  )

  def __init__(self, values=None, lastKey=None, skipKeys=None,):
    self.values = values
    self.lastKey = lastKey
    self.skipKeys = skipKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype102, _size99) = iprot.readListBegin()
          for _i103 in xrange(_size99):
            _elem104 = KeyValueItem()
            _elem104.read(iprot)
            self.values.append(_elem104)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.lastKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.skipKeys = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IteratorResponse')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter105 in self.values:
        iter105.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.lastKey is not None:
      oprot.writeFieldBegin('lastKey', TType.STRING, 2)
      oprot.writeString(self.lastKey)
      oprot.writeFieldEnd()
    if self.skipKeys is not None:
      oprot.writeFieldBegin('skipKeys', TType.I32, 3)
      oprot.writeI32(self.skipKeys)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.lastKey)
    value = (value * 31) ^ hash(self.skipKeys)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HFileInfo:
  """
  Attributes:
   - name
   - path
   - numElements
   - firstKey
   - lastKey
   - randomKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'path', None, None, ), # 2
    (3, TType.I64, 'numElements', None, None, ), # 3
    (4, TType.STRING, 'firstKey', None, None, ), # 4
    (5, TType.STRING, 'lastKey', None, None, ), # 5
    (6, TType.LIST, 'randomKeys', (TType.STRING,None), None, ), # 6
  )

  def __init__(self, name=None, path=None, numElements=None, firstKey=None, lastKey=None, randomKeys=None,):
    self.name = name
    self.path = path
    self.numElements = numElements
    self.firstKey = firstKey
    self.lastKey = lastKey
    self.randomKeys = randomKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numElements = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.firstKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.lastKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.randomKeys = []
          (_etype109, _size106) = iprot.readListBegin()
          for _i110 in xrange(_size106):
            _elem111 = iprot.readString();
            self.randomKeys.append(_elem111)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HFileInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 2)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.numElements is not None:
      oprot.writeFieldBegin('numElements', TType.I64, 3)
      oprot.writeI64(self.numElements)
      oprot.writeFieldEnd()
    if self.firstKey is not None:
      oprot.writeFieldBegin('firstKey', TType.STRING, 4)
      oprot.writeString(self.firstKey)
      oprot.writeFieldEnd()
    if self.lastKey is not None:
      oprot.writeFieldBegin('lastKey', TType.STRING, 5)
      oprot.writeString(self.lastKey)
      oprot.writeFieldEnd()
    if self.randomKeys is not None:
      oprot.writeFieldBegin('randomKeys', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.randomKeys))
      for iter112 in self.randomKeys:
        oprot.writeString(iter112)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.path)
    value = (value * 31) ^ hash(self.numElements)
    value = (value * 31) ^ hash(self.firstKey)
    value = (value * 31) ^ hash(self.lastKey)
    value = (value * 31) ^ hash(self.randomKeys)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InfoRequest:
  """
  Attributes:
   - hfileName
   - numRandomKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hfileName', None, None, ), # 1
    (2, TType.I64, 'numRandomKeys', None, None, ), # 2
  )

  def __init__(self, hfileName=None, numRandomKeys=None,):
    self.hfileName = hfileName
    self.numRandomKeys = numRandomKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hfileName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.numRandomKeys = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InfoRequest')
    if self.hfileName is not None:
      oprot.writeFieldBegin('hfileName', TType.STRING, 1)
      oprot.writeString(self.hfileName)
      oprot.writeFieldEnd()
    if self.numRandomKeys is not None:
      oprot.writeFieldBegin('numRandomKeys', TType.I64, 2)
      oprot.writeI64(self.numRandomKeys)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hfileName)
    value = (value * 31) ^ hash(self.numRandomKeys)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
